use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

grammar<'err>(
                errors: &'err mut Vec<ErrorRecovery<usize,
                Token<'input>, 
                &'static str>>
             );

pub Spec: &'input str = {
    "module" Name "is"
        Data
        Members
        Body
    "end" Name  => ""
};

Data: &'input str = {
    <Scheme+> => ""
}

Body: &'input str = {
    <Action+> => ""
}

Scheme: &'input str = {
    Name "is" "in" Set Where_Clause* => "",
    Name "are" Set Where_Clause* => ""
}
Where_Clause: &'input str = {
    "where" ":" Expr "."  => ""
}

Set: &'input str = {
    Expr => "",
    "{" Set ("," Set)* "}" => ""
}

Members: &'input str = {
    "members" "are" "{" Set ("," Set)* "}"  => ""
}


Action: &'input str = {
    "action" (Name)? "is"
        When_Block ("or" When_Block)*
        Then_Block ("or" Then_Block)*
    "end" "action"  => ""
}

When_Block: &'input str = {
    "when" Quantifiers? ":"
        Stmt* => ""
}
Then_Block: &'input str = {
    "then" ":"
        Stmt+ => ""
}

Quantifiers: &'input str = {
    "any" => "",
    "all" => "",
    "at" "most" Num => "",
    "at" "least" Num => "",
    "always" => "",
}

Stmt: &'input str = {
    If_Stmt => "",
    Selection_Stmt "." => "",
    Assignment "." => ""
}

Selection_Stmt: &'input str = {
    "for"  Name "in" Expr Filter? => "",
    "for" "some" Name "in" Expr Filter? => "",
    "for" "all" Name "in" Expr Filter? => ""
}
Filter: &'input str = {
    "such" "that" Expr => ""
}

If_Stmt: &'input str = {

    "if" Expr "then" ":"
        Stmt+

    Else_If*

    Else?

    "end" "if" => ""

}

Else_If: &'input str = {
    "elsif" Expr "then" ":"
        Stmt+ => ""
}

Else: &'input str = {
    "else" ":"
        Stmt+  => ""
}

Assignment: &'input str = {
    Name r#"'"# ":=" Expr => ""
}
//todo, let := will-be

Expr: &'input str = {

    #[precedence(level="0")]
    Membership => "",

    #[precedence(level="1")] #[assoc(side="left")]
    Expr "equals" Membership => "",
    Expr "not-equals" Membership => "",

    // Conditional Exprssions:
    #[precedence(level="2")] #[assoc(side="left")]
    Expr "and" Membership => "",
    Expr "or" Membership => "",
    Expr "or-rather" Membership => "",

    #[precedence(level="3")] #[assoc(side="left")]
    "not" Expr => "",

}

Membership: &'input str = {

    Arithmatic => "",

    Membership "is"? "between" Arithmatic ".." Arithmatic => "",
    Membership "is"? "in" Arithmatic => "",
    "is" "between" Arithmatic ".." Arithmatic => "",
    "is" "in" Arithmatic => ""

}

Arithmatic: &'input str = {

    #[precedence(level="0")]
    Term => "",

    #[precedence(level="1")] #[assoc(side="left")]
    Arithmatic "*" Term => "",
    Arithmatic "/" Term => "",

    #[precedence(level="2")] #[assoc(side="left")]
    Arithmatic "+" Term => "",
    Arithmatic "-" Term => "",

    #[precedence(level="3")] #[assoc(side="left")]
    "-" Arithmatic => "",
}

Term: &'input str = {
    Name => <>,
    Num => "",
    "(" Expr ")" => "",
    "members" => ""
    //function call here
}


Name: &'input str = {
    Word ("->" Word )* => ""
}

Word: &'input str = {
    <r"[a-zA-Z_][a-zA-Z-9_]*"> => <>
}

Num: u32 = {
    <r"[0-9]+"> => u32::from_str(<>).unwrap()
}


